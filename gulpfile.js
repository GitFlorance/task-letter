const path = require('path');
const { src, dest, watch, series, parallel } = require('gulp');
const mjml = require('gulp-mjml');
const mjmlEngine = require('mjml');
const header = require('gulp-header');
const gulpLoadPlugins = require('gulp-load-plugins');

const browserSync = require('browser-sync');
const fs = require('fs');
const Freemarker = require('freemarker');
var del = require('del');
const autoprefixer = require('autoprefixer');
const cssnano = require('cssnano');
const $ = gulpLoadPlugins();
const server = browserSync.create();

let headerContent = '<!-- WARNING! THIS IS AUTOGENERATED FILE. PLEASE DON\'T CHANGE IT MANUALLY! -->\n';
headerContent += '<#setting locale="ru_RU">\n';

function handleError(err) {
  console.log(err.toString());
  this.emit('end');
}


async function styles() {
  const isProd = process.env.NODE_ENV === 'production';
  return new Promise((resolve, reject) => src('src/pdf/**/*.scss')
    .pipe($.plumber())
    .pipe($.if(!isProd, $.sourcemaps.init()))
    .pipe($.if(isProd, $.sassVariables(
      {
        $assetsPrefix: "http://${host_name}/s3"
      }
    )))
    .pipe($.sass.sync({
      outputStyle: 'expanded',
      precision: 10,
      includePaths: ['.']
    })
      .on('error', (error) => {
        $.sass.logError(error);
        handleError(error)
        reject();
      }))
    .pipe($.postcss([
      autoprefixer()
    ]))
    .pipe($.if(!isProd, $.sourcemaps.write()))
    .on('error', (error) => {
      handleError(error);
      reject();
    })
    .pipe($.rename({ dirname: '' }))
    .pipe(dest('.tmp'))
    .on('end', resolve)
  );
};

function html() {
  const isProd = process.env.NODE_ENV === 'production';

  return src('src/pdf/**/*.template.html')
    .pipe($.rename(function (opt) {
      opt.basename = opt.basename.replace(/(\.template)/, '');
      return opt;
    }))
    .pipe($.if(/\.css$/, $.postcss([cssnano({ safe: true, autoprefixer: false })])))
    .pipe($.if(/\.html$/, $.htmlmin({
      collapseWhitespace: true,
      minifyCSS: true,
      minifyJS: {compress: {drop_console: true}},
      processConditionalComments: true,
      removeComments: true,
      removeEmptyAttributes: true,
      removeScriptTypeAttributes: true,
      removeStyleLinkTypeAttributes: true
    })))
    .pipe($.inlineSource({ rootpath: path.resolve(__dirname, '.tmp/') }))
}

function renderFreemarker(pathToReplace = 'html') {
  async function transform(file, cb) {
    const html = file.contents.toString();
    const freemarker = new Freemarker();
    const jsonData = await JSON.parse(fs.readFileSync(file.path.replace(pathToReplace, 'json')));
    jsonData.host_name = "развивай.рф";

    freemarker.render(html, jsonData, (err, result) => {
      if (err) {
        throw new Error(err);
      }

      file.contents = new Buffer.from(result);

      cb(null, file);
    });
  }

  return require('event-stream').map(transform);
}

async function renderHtml() {
  return new Promise((resolve, reject) => {
    html()
      .pipe(renderFreemarker())
      .pipe(dest('build/pdf/'))
      .on('error', (error) => {
        reject();
        handleError(error);
      })
      .on('end', resolve)
  });
};

async function renderMjml() {
  return new Promise((resolve, reject) => {
    src('src/**/*.mjml')
      .pipe(mjml(mjmlEngine, {
        validationLevel: 'strict',
        keepComments: true,
        beautify: true
      }))
      .on('error', (error) => {
        reject();
        handleError(error);
      })
      .pipe(header(headerContent))
      .pipe(dest(function (file) {
        return file.base;
      }))
      .pipe(renderFreemarker())
      .pipe(dest('build/email/'))
      .on('end', resolve);
  });
};

function buildFreemarker() {
  return src('src/**/*.mjml')
    .pipe(mjml(mjmlEngine, {
      validationLevel: 'strict',
      keepComments: true,
      beautify: true
    }))
    .on('error', handleError)
    .pipe(header(headerContent))
    .pipe(dest(function (file) {
      return file.base;
    }));
}
async function buildPdfFreemarker() {
  return new Promise((resolve, reject) => {
    html()
      .pipe(header(headerContent))
      .pipe(dest('src/pdf/'))
      .on('end', resolve);
  });
};

function hotReload(cb) {
  server.reload();
  cb();
};

function initBrowserSync() {
  server.init({
    server: {
      baseDir: "./build",
      routes: {
        "/s3": "../s3"
      },
      directory: true
    }
  });
}

async function clean() {
  return del(['./build/**', '.tmp/**', '!./build']);
}

exports.buildHtml = () => {
  process.env.NODE_ENV = 'production';
  return buildFreemarker();
};

exports.buildPdf = () => {
  process.env.NODE_ENV = 'production';
  return buildPdfFreemarker();
};

exports.build = async () => {
  process.env.NODE_ENV = 'production';
  await clean();
  await styles();
  await buildFreemarker();
  await buildPdfFreemarker();
};

exports.default = async function () {
  await clean();
  await styles();
  await renderHtml();
  await renderMjml();
  initBrowserSync();

  watch('src/**/*.scss', series(styles, renderHtml, hotReload));
  watch(['src/**/*.mjml', 'src/**/*.json'], series(renderMjml, hotReload));
  watch(['src/pdf/**/*.template.html', 'src/pdf/**/*.json'], series(renderHtml, hotReload));
};
